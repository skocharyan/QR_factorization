var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"Fixed_point_conveted_LCMV_2/Time Delayed LCMV Beamformer/lcmv weigth calculator simplified/qrlinsolve/QR Factorization ","ref":false,"files":[{"name":"QR0.c","type":"source","group":"model","path":"E:\\Projects\\Matlab\\Beamformer\\LCMV_Simulink\\QR0_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * QR0.c\r\n *\r\n * Code generation for model \"QR0\".\r\n *\r\n * Model version              : 1.312\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Tue Nov 21 14:00:25 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ASIC/FPGA->ASIC/FPGA\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (Custom Processor->MATLAB Host Computer)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"QR0.h\"\r\n#include \"rtwtypes.h\"\r\n#include <string.h>\r\n#include <math.h>\r\n#include \"QR0_private.h\"\r\n#include <emmintrin.h>\r\n\r\n/* Block signals (default storage) */\r\nB_QR0_T QR0_B;\r\n\r\n/* Block states (default storage) */\r\nDW_QR0_T QR0_DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU_QR0_T QR0_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_QR0_T QR0_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_QR0_T QR0_M_;\r\nRT_MODEL_QR0_T *const QR0_M = &QR0_M_;\r\n\r\n/* Forward declaration for local functions */\r\nstatic real_T QR0_xnrm2(int32_T n, const creal_T x[1040], int32_T ix0);\r\nstatic real_T QR0_xdlapy3(real_T x1, real_T x2, real_T x3);\r\nstatic creal_T QR0_recip(const creal_T y);\r\nstatic void QR0_xzlarf_c(int32_T m, int32_T n, int32_T iv0, const creal_T tau,\r\n  const creal_T C[1040], int32_T ic0, creal_T work[4], creal_T b_C[1040]);\r\nstatic void QR0_xgeqp3(const creal_T A[1040], creal_T b_A[1040], creal_T tau[4],\r\n  int32_T jpvt[4]);\r\nint32_T div_nde_s32_floor(int32_T numerator, int32_T denominator)\r\n{\r\n  return (((numerator < 0) != (denominator < 0)) && (numerator % denominator !=\r\n           0) ? -1 : 0) + numerator / denominator;\r\n}\r\n\r\nreal_T rt_hypotd(real_T u0, real_T u1)\r\n{\r\n  real_T a;\r\n  real_T b;\r\n  real_T y;\r\n  a = fabs(u0);\r\n  b = fabs(u1);\r\n  if (a < b) {\r\n    a /= b;\r\n    y = sqrt(a * a + 1.0) * b;\r\n  } else if (a > b) {\r\n    b /= a;\r\n    y = sqrt(b * b + 1.0) * a;\r\n  } else {\r\n    y = a * 1.4142135623730951;\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nstatic real_T QR0_xnrm2(int32_T n, const creal_T x[1040], int32_T ix0)\r\n{\r\n  real_T absxk;\r\n  real_T scale;\r\n  real_T t;\r\n  real_T y;\r\n  int32_T k;\r\n  int32_T kend;\r\n  y = 0.0;\r\n  if (n < 1) {\r\n  } else if (n == 1) {\r\n    y = rt_hypotd(x[ix0 - 1].re, x[ix0 - 1].im);\r\n  } else {\r\n    scale = 3.3121686421112381E-170;\r\n    kend = ix0 + n;\r\n    for (k = ix0; k < kend; k++) {\r\n      absxk = fabs(x[k - 1].re);\r\n      if (absxk > scale) {\r\n        t = scale / absxk;\r\n        y = y * t * t + 1.0;\r\n        scale = absxk;\r\n      } else {\r\n        t = absxk / scale;\r\n        y += t * t;\r\n      }\r\n\r\n      absxk = fabs(x[k - 1].im);\r\n      if (absxk > scale) {\r\n        t = scale / absxk;\r\n        y = y * t * t + 1.0;\r\n        scale = absxk;\r\n      } else {\r\n        t = absxk / scale;\r\n        y += t * t;\r\n      }\r\n    }\r\n\r\n    y = scale * sqrt(y);\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nstatic real_T QR0_xdlapy3(real_T x1, real_T x2, real_T x3)\r\n{\r\n  real_T a;\r\n  real_T b;\r\n  real_T c;\r\n  real_T y;\r\n  a = fabs(x1);\r\n  b = fabs(x2);\r\n  c = fabs(x3);\r\n  y = fmax(a, b);\r\n  if (c > y) {\r\n    y = c;\r\n  }\r\n\r\n  if (y > 0.0) {\r\n    a /= y;\r\n    b /= y;\r\n    c /= y;\r\n    y *= sqrt((a * a + c * c) + b * b);\r\n  } else {\r\n    y = (a + b) + c;\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nstatic creal_T QR0_recip(const creal_T y)\r\n{\r\n  creal_T z;\r\n  real_T bim;\r\n  real_T brm;\r\n  brm = fabs(y.re);\r\n  bim = fabs(y.im);\r\n  if (y.im == 0.0) {\r\n    z.re = 1.0 / y.re;\r\n    z.im = 0.0;\r\n  } else if (y.re == 0.0) {\r\n    z.re = 0.0;\r\n    z.im = -1.0 / y.im;\r\n  } else if (brm > bim) {\r\n    brm = y.im / y.re;\r\n    _mm_storeu_pd((real_T *)&z, _mm_div_pd(_mm_set_pd(-brm, 1.0), _mm_set1_pd\r\n      (brm * y.im + y.re)));\r\n  } else if (brm == bim) {\r\n    real_T br;\r\n    bim = 0.5;\r\n    if (y.re < 0.0) {\r\n      bim = -0.5;\r\n    }\r\n\r\n    br = 0.5;\r\n    if (y.im < 0.0) {\r\n      br = -0.5;\r\n    }\r\n\r\n    _mm_storeu_pd((real_T *)&z, _mm_div_pd(_mm_set_pd(-br, bim), _mm_set1_pd(brm)));\r\n  } else {\r\n    brm = y.re / y.im;\r\n    _mm_storeu_pd((real_T *)&z, _mm_div_pd(_mm_set_pd(-1.0, brm), _mm_set1_pd\r\n      (brm * y.re + y.im)));\r\n  }\r\n\r\n  return z;\r\n}\r\n\r\nstatic void QR0_xzlarf_c(int32_T m, int32_T n, int32_T iv0, const creal_T tau,\r\n  const creal_T C[1040], int32_T ic0, creal_T work[4], creal_T b_C[1040])\r\n{\r\n  real_T tmp_0[2];\r\n  int32_T coltop;\r\n  int32_T iac;\r\n  int32_T ijA;\r\n  int32_T jA;\r\n  int32_T lastc;\r\n  int32_T lastv;\r\n  memcpy(&b_C[0], &C[0], 1040U * sizeof(creal_T));\r\n  if ((tau.re != 0.0) || (tau.im != 0.0)) {\r\n    boolean_T exitg2;\r\n    lastv = m;\r\n    lastc = (iv0 + m) - 2;\r\n    while ((lastv > 0) && ((C[lastc].re == 0.0) && (C[lastc].im == 0.0))) {\r\n      lastv--;\r\n      lastc--;\r\n    }\r\n\r\n    lastc = n - 1;\r\n    exitg2 = false;\r\n    while ((!exitg2) && (lastc + 1 > 0)) {\r\n      int32_T exitg1;\r\n      coltop = lastc * 260 + ic0;\r\n      jA = coltop;\r\n      do {\r\n        exitg1 = 0;\r\n        if (jA <= (coltop + lastv) - 1) {\r\n          if ((C[jA - 1].re != 0.0) || (C[jA - 1].im != 0.0)) {\r\n            exitg1 = 1;\r\n          } else {\r\n            jA++;\r\n          }\r\n        } else {\r\n          lastc--;\r\n          exitg1 = 2;\r\n        }\r\n      } while (exitg1 == 0);\r\n\r\n      if (exitg1 == 1) {\r\n        exitg2 = true;\r\n      }\r\n    }\r\n  } else {\r\n    lastv = 0;\r\n    lastc = -1;\r\n  }\r\n\r\n  if (lastv > 0) {\r\n    real_T alpha1_im;\r\n    real_T alpha1_re;\r\n    real_T c_im;\r\n    real_T c_re;\r\n    int32_T d;\r\n    if (lastc + 1 != 0) {\r\n      if (lastc >= 0) {\r\n        memset(&work[0], 0, (uint32_T)(lastc + 1) * sizeof(creal_T));\r\n      }\r\n\r\n      coltop = 260 * lastc + ic0;\r\n      for (iac = ic0; iac <= coltop; iac += 260) {\r\n        __m128d tmp;\r\n        c_re = 0.0;\r\n        c_im = 0.0;\r\n        d = iac + lastv;\r\n        for (jA = iac; jA < d; jA++) {\r\n          ijA = ((iv0 + jA) - iac) - 1;\r\n          tmp = _mm_add_pd(_mm_add_pd(_mm_mul_pd(_mm_loadu_pd((const real_T *)\r\n            &b_C[ijA]), _mm_set1_pd(b_C[jA - 1].re)), _mm_mul_pd(_mm_mul_pd\r\n            (_mm_shuffle_pd(_mm_loadu_pd((const real_T *)&b_C[ijA]),\r\n                            _mm_loadu_pd((const real_T *)&b_C[ijA]), 1),\r\n             _mm_set1_pd(b_C[jA - 1].im)), _mm_set_pd(-1.0, 1.0))), _mm_set_pd\r\n                           (c_im, c_re));\r\n          _mm_storeu_pd(&tmp_0[0], tmp);\r\n          c_re = tmp_0[0];\r\n          c_im = tmp_0[1];\r\n        }\r\n\r\n        ijA = div_nde_s32_floor(iac - ic0, 260);\r\n        tmp = _mm_add_pd(_mm_loadu_pd((const real_T *)&work[ijA]), _mm_set_pd\r\n                         (c_im, c_re));\r\n        _mm_storeu_pd((real_T *)&work[ijA], tmp);\r\n      }\r\n    }\r\n\r\n    alpha1_re = -tau.re;\r\n    alpha1_im = -tau.im;\r\n    if ((-tau.re != 0.0) || (-tau.im != 0.0)) {\r\n      jA = ic0;\r\n      for (iac = 0; iac <= lastc; iac++) {\r\n        real_T work_im;\r\n        c_im = work[iac].re;\r\n        work_im = work[iac].im;\r\n        if ((c_im != 0.0) || (work_im != 0.0)) {\r\n          c_re = c_im * alpha1_re + work_im * alpha1_im;\r\n          c_im = c_im * alpha1_im - work_im * alpha1_re;\r\n          d = (lastv + jA) - 1;\r\n          for (ijA = jA; ijA <= d; ijA++) {\r\n            real_T b_C_im_tmp;\r\n            coltop = ((iv0 + ijA) - jA) - 1;\r\n            work_im = b_C[coltop].re;\r\n            b_C_im_tmp = b_C[coltop].im;\r\n            b_C[ijA - 1].re += work_im * c_re - b_C_im_tmp * c_im;\r\n            b_C[ijA - 1].im += work_im * c_im + b_C_im_tmp * c_re;\r\n          }\r\n        }\r\n\r\n        jA += 260;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nstatic void QR0_xgeqp3(const creal_T A[1040], creal_T b_A[1040], creal_T tau[4],\r\n  int32_T jpvt[4])\r\n{\r\n  __m128d tmp_0;\r\n  creal_T work[4];\r\n  creal_T b_A_0;\r\n  creal_T c_atmp;\r\n  creal_T tau_0;\r\n  creal_T tmp;\r\n  real_T vn1[4];\r\n  real_T vn2[4];\r\n  real_T absxk;\r\n  real_T b_A_1;\r\n  real_T beta1;\r\n  real_T scale;\r\n  real_T t;\r\n  int32_T b_A_tmp;\r\n  int32_T b_k;\r\n  int32_T itemp;\r\n  int32_T ix;\r\n  int32_T iy;\r\n  int32_T j;\r\n  int32_T kend;\r\n  int32_T nmip1;\r\n  int32_T temp_re_tmp;\r\n  memcpy(&b_A[0], &A[0], 1040U * sizeof(creal_T));\r\n  memset(&tau[0], 0, sizeof(creal_T) << 2U);\r\n  work[0].re = 0.0;\r\n  work[0].im = 0.0;\r\n  work[1].re = 0.0;\r\n  work[1].im = 0.0;\r\n  work[2].re = 0.0;\r\n  work[2].im = 0.0;\r\n  work[3].re = 0.0;\r\n  work[3].im = 0.0;\r\n  for (b_k = 0; b_k < 4; b_k++) {\r\n    jpvt[b_k] = b_k + 1;\r\n    ix = b_k * 260;\r\n    beta1 = 0.0;\r\n    scale = 3.3121686421112381E-170;\r\n    for (itemp = ix + 1; itemp <= ix + 260; itemp++) {\r\n      absxk = fabs(A[itemp - 1].re);\r\n      if (absxk > scale) {\r\n        t = scale / absxk;\r\n        beta1 = beta1 * t * t + 1.0;\r\n        scale = absxk;\r\n      } else {\r\n        t = absxk / scale;\r\n        beta1 += t * t;\r\n      }\r\n\r\n      absxk = fabs(A[itemp - 1].im);\r\n      if (absxk > scale) {\r\n        t = scale / absxk;\r\n        beta1 = beta1 * t * t + 1.0;\r\n        scale = absxk;\r\n      } else {\r\n        t = absxk / scale;\r\n        beta1 += t * t;\r\n      }\r\n    }\r\n\r\n    absxk = scale * sqrt(beta1);\r\n    vn1[b_k] = absxk;\r\n    vn2[b_k] = absxk;\r\n  }\r\n\r\n  for (b_k = 0; b_k < 4; b_k++) {\r\n    j = b_k + 1;\r\n    kend = b_k * 260 + b_k;\r\n    nmip1 = 4 - b_k;\r\n    iy = 0;\r\n    if (4 - b_k > 1) {\r\n      scale = vn1[b_k];\r\n      for (itemp = 2; itemp <= nmip1; itemp++) {\r\n        absxk = vn1[(b_k + itemp) - 1];\r\n        if (absxk > scale) {\r\n          iy = itemp - 1;\r\n          scale = absxk;\r\n        }\r\n      }\r\n    }\r\n\r\n    nmip1 = b_k + iy;\r\n    if (nmip1 != b_k) {\r\n      ix = nmip1 * 260;\r\n      iy = b_k * 260;\r\n      for (itemp = 0; itemp < 260; itemp++) {\r\n        temp_re_tmp = ix + itemp;\r\n        scale = b_A[temp_re_tmp].re;\r\n        absxk = b_A[temp_re_tmp].im;\r\n        b_A_tmp = iy + itemp;\r\n        b_A[temp_re_tmp] = b_A[b_A_tmp];\r\n        b_A[b_A_tmp].re = scale;\r\n        b_A[b_A_tmp].im = absxk;\r\n      }\r\n\r\n      itemp = jpvt[nmip1];\r\n      jpvt[nmip1] = jpvt[b_k];\r\n      jpvt[b_k] = itemp;\r\n      vn1[nmip1] = vn1[b_k];\r\n      vn2[nmip1] = vn2[b_k];\r\n    }\r\n\r\n    ix = kend + 2;\r\n    scale = b_A[kend].re;\r\n    absxk = b_A[kend].im;\r\n    tau[b_k].re = 0.0;\r\n    tau[b_k].im = 0.0;\r\n    beta1 = QR0_xnrm2(259 - b_k, b_A, kend + 2);\r\n    if ((beta1 != 0.0) || (b_A[kend].im != 0.0)) {\r\n      beta1 = QR0_xdlapy3(scale, absxk, beta1);\r\n      if (scale >= 0.0) {\r\n        beta1 = -beta1;\r\n      }\r\n\r\n      if (fabs(beta1) < 1.0020841800044864E-292) {\r\n        iy = -1;\r\n        do {\r\n          iy++;\r\n          nmip1 = (kend - b_k) + 260;\r\n          for (itemp = ix; itemp <= nmip1; itemp++) {\r\n            tmp_0 = _mm_mul_pd(_mm_loadu_pd((const real_T *)&b_A[itemp - 1]),\r\n                               _mm_set1_pd(9.9792015476736E+291));\r\n            _mm_storeu_pd((real_T *)&b_A[itemp - 1], tmp_0);\r\n          }\r\n\r\n          beta1 *= 9.9792015476736E+291;\r\n          scale *= 9.9792015476736E+291;\r\n          absxk *= 9.9792015476736E+291;\r\n        } while ((fabs(beta1) < 1.0020841800044864E-292) && (iy + 1 < 20));\r\n\r\n        beta1 = QR0_xdlapy3(scale, absxk, QR0_xnrm2(259 - b_k, b_A, kend + 2));\r\n        if (scale >= 0.0) {\r\n          beta1 = -beta1;\r\n        }\r\n\r\n        t = beta1 - scale;\r\n        if (0.0 - absxk == 0.0) {\r\n          tau[b_k].re = t / beta1;\r\n          tau[b_k].im = 0.0;\r\n        } else if (t == 0.0) {\r\n          tau[b_k].re = 0.0;\r\n          tau[b_k].im = (0.0 - absxk) / beta1;\r\n        } else {\r\n          tau[b_k].re = t / beta1;\r\n          tau[b_k].im = (0.0 - absxk) / beta1;\r\n        }\r\n\r\n        c_atmp.re = scale - beta1;\r\n        c_atmp.im = absxk;\r\n        tmp = QR0_recip(c_atmp);\r\n        scale = tmp.re;\r\n        absxk = tmp.im;\r\n        for (itemp = ix; itemp <= nmip1; itemp++) {\r\n          t = b_A[itemp - 1].im;\r\n          b_A_1 = b_A[itemp - 1].re;\r\n          b_A[itemp - 1].re = b_A_1 * scale - t * absxk;\r\n          b_A[itemp - 1].im = t * scale + b_A_1 * absxk;\r\n        }\r\n\r\n        for (itemp = 0; itemp <= iy; itemp++) {\r\n          beta1 *= 1.0020841800044864E-292;\r\n        }\r\n\r\n        scale = beta1;\r\n        absxk = 0.0;\r\n      } else {\r\n        t = beta1 - scale;\r\n        if (0.0 - absxk == 0.0) {\r\n          tau[b_k].re = t / beta1;\r\n          tau[b_k].im = 0.0;\r\n        } else if (t == 0.0) {\r\n          tau[b_k].re = 0.0;\r\n          tau[b_k].im = (0.0 - absxk) / beta1;\r\n        } else {\r\n          tau[b_k].re = t / beta1;\r\n          tau[b_k].im = (0.0 - absxk) / beta1;\r\n        }\r\n\r\n        b_A_0.re = scale - beta1;\r\n        b_A_0.im = absxk;\r\n        tmp = QR0_recip(b_A_0);\r\n        scale = tmp.re;\r\n        absxk = tmp.im;\r\n        nmip1 = (kend - b_k) - 1;\r\n        for (itemp = ix; itemp <= nmip1 + 261; itemp++) {\r\n          t = b_A[itemp - 1].im;\r\n          b_A_1 = b_A[itemp - 1].re;\r\n          b_A[itemp - 1].re = b_A_1 * scale - t * absxk;\r\n          b_A[itemp - 1].im = t * scale + b_A_1 * absxk;\r\n        }\r\n\r\n        scale = beta1;\r\n        absxk = 0.0;\r\n      }\r\n    }\r\n\r\n    b_A[kend].re = scale;\r\n    b_A[kend].im = absxk;\r\n    if (b_k + 1 < 4) {\r\n      b_A[kend].re = 1.0;\r\n      b_A[kend].im = 0.0;\r\n      tau_0.re = tau[b_k].re;\r\n      tau_0.im = -tau[b_k].im;\r\n      memcpy(&QR0_B.b_A_m[0], &b_A[0], 1040U * sizeof(creal_T));\r\n      QR0_xzlarf_c(260 - b_k, 3 - b_k, kend + 1, tau_0, QR0_B.b_A_m, kend + 261,\r\n                   work, b_A);\r\n      b_A[kend].re = scale;\r\n      b_A[kend].im = absxk;\r\n    }\r\n\r\n    for (nmip1 = j + 1; nmip1 < 5; nmip1++) {\r\n      itemp = ((nmip1 - 1) * 260 + b_k) + 1;\r\n      absxk = vn1[nmip1 - 1];\r\n      if (absxk != 0.0) {\r\n        beta1 = rt_hypotd(b_A[itemp - 1].re, b_A[itemp - 1].im) / absxk;\r\n        beta1 = 1.0 - beta1 * beta1;\r\n        if (beta1 < 0.0) {\r\n          beta1 = 0.0;\r\n        }\r\n\r\n        scale = absxk / vn2[nmip1 - 1];\r\n        scale = scale * scale * beta1;\r\n        if (scale <= 1.4901161193847656E-8) {\r\n          ix = itemp;\r\n          beta1 = 0.0;\r\n          scale = 3.3121686421112381E-170;\r\n          kend = (itemp - b_k) - 1;\r\n          for (itemp = ix + 1; itemp <= kend + 260; itemp++) {\r\n            absxk = fabs(b_A[itemp - 1].re);\r\n            if (absxk > scale) {\r\n              t = scale / absxk;\r\n              beta1 = beta1 * t * t + 1.0;\r\n              scale = absxk;\r\n            } else {\r\n              t = absxk / scale;\r\n              beta1 += t * t;\r\n            }\r\n\r\n            absxk = fabs(b_A[itemp - 1].im);\r\n            if (absxk > scale) {\r\n              t = scale / absxk;\r\n              beta1 = beta1 * t * t + 1.0;\r\n              scale = absxk;\r\n            } else {\r\n              t = absxk / scale;\r\n              beta1 += t * t;\r\n            }\r\n          }\r\n\r\n          beta1 = scale * sqrt(beta1);\r\n          vn1[nmip1 - 1] = beta1;\r\n          vn2[nmip1 - 1] = beta1;\r\n        } else {\r\n          vn1[nmip1 - 1] = absxk * sqrt(beta1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/* Model step function */\r\nvoid QR0_step(void)\r\n{\r\n  creal_T b_R[16];\r\n  creal_T tau[4];\r\n  int32_T b_jpvt[4];\r\n  int32_T b_i;\r\n  int32_T b_j;\r\n  int32_T tmp;\r\n\r\n  /* MATLABSystem: '<S1>/QR Factor with pivot' incorporates:\r\n   *  Inport: '<Root>/A'\r\n   */\r\n  QR0_xgeqp3(QR0_U.A, QR0_B.b_A, tau, b_jpvt);\r\n  for (b_j = 0; b_j < 4; b_j++) {\r\n    for (b_i = 0; b_i <= b_j; b_i++) {\r\n      b_R[b_i + (b_j << 2)] = QR0_B.b_A[260 * b_j + b_i];\r\n    }\r\n\r\n    for (b_i = b_j + 2; b_i < 5; b_i++) {\r\n      tmp = ((b_j << 2) + b_i) - 1;\r\n      b_R[tmp].re = 0.0;\r\n      b_R[tmp].im = 0.0;\r\n    }\r\n  }\r\n\r\n  /* Outport: '<Root>/Out1' incorporates:\r\n   *  MATLABSystem: '<S1>/QR Factor with pivot'\r\n   */\r\n  memcpy(&QR0_Y.Out1[0], &b_R[0], sizeof(creal_T) << 4U);\r\n\r\n  /* Outport: '<Root>/PIVOTPERM' incorporates:\r\n   *  MATLABSystem: '<S1>/QR Factor with pivot'\r\n   */\r\n  QR0_Y.PIVOTPERM[0] = b_jpvt[0];\r\n  QR0_Y.PIVOTPERM[1] = b_jpvt[1];\r\n  QR0_Y.PIVOTPERM[2] = b_jpvt[2];\r\n  QR0_Y.PIVOTPERM[3] = b_jpvt[3];\r\n}\r\n\r\n/* Model initialize function */\r\nvoid QR0_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize error status */\r\n  rtmSetErrorStatus(QR0_M, (NULL));\r\n\r\n  /* states (dwork) */\r\n  (void) memset((void *)&QR0_DW, 0,\r\n                sizeof(DW_QR0_T));\r\n\r\n  /* external inputs */\r\n  (void)memset(&QR0_U, 0, sizeof(ExtU_QR0_T));\r\n\r\n  /* external outputs */\r\n  (void)memset(&QR0_Y, 0, sizeof(ExtY_QR0_T));\r\n\r\n  /* Start for MATLABSystem: '<S1>/QR Factor with pivot' */\r\n  QR0_DW.objisempty = true;\r\n  QR0_DW.obj.isInitialized = 1;\r\n}\r\n\r\n/* Model terminate function */\r\nvoid QR0_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n"},{"name":"QR0.h","type":"header","group":"model","path":"E:\\Projects\\Matlab\\Beamformer\\LCMV_Simulink\\QR0_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * QR0.h\r\n *\r\n * Code generation for model \"QR0\".\r\n *\r\n * Model version              : 1.312\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Tue Nov 21 14:00:25 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ASIC/FPGA->ASIC/FPGA\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (Custom Processor->MATLAB Host Computer)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_QR0_h_\r\n#define RTW_HEADER_QR0_h_\r\n#ifndef QR0_COMMON_INCLUDES_\r\n#define QR0_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n#endif                                 /* QR0_COMMON_INCLUDES_ */\r\n\r\n#include \"QR0_types.h\"\r\n#include <stddef.h>\r\n#include <string.h>\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  creal_T b_A[1040];\r\n  creal_T b_A_m[1040];\r\n} B_QR0_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  dsp_simulink_QRFactorization__T obj; /* '<S1>/QR Factor with pivot' */\r\n  boolean_T objisempty;                /* '<S1>/QR Factor with pivot' */\r\n} DW_QR0_T;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  creal_T A[1040];                     /* '<Root>/A' */\r\n} ExtU_QR0_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  creal_T Out1[16];                    /* '<Root>/Out1' */\r\n  real_T PIVOTPERM[4];                 /* '<Root>/PIVOTPERM' */\r\n} ExtY_QR0_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_QR0_T {\r\n  const char_T *errorStatus;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern B_QR0_T QR0_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_QR0_T QR0_DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU_QR0_T QR0_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY_QR0_T QR0_Y;\r\n\r\n/* Model entry point functions */\r\nextern void QR0_initialize(void);\r\nextern void QR0_step(void);\r\nextern void QR0_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_QR0_T *const QR0_M;\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Note that this particular code originates from a subsystem build,\r\n * and has its own system numbers different from the parent model.\r\n * Refer to the system hierarchy for this subsystem below, and use the\r\n * MATLAB hilite_system command to trace the generated code back\r\n * to the parent model.  For example,\r\n *\r\n * hilite_system('Fixed_point_conveted_LCMV_2/Time Delayed LCMV Beamformer/lcmv weigth calculator simplified/qrlinsolve/QR Factorization ')    - opens subsystem Fixed_point_conveted_LCMV_2/Time Delayed LCMV Beamformer/lcmv weigth calculator simplified/qrlinsolve/QR Factorization\r\n * hilite_system('Fixed_point_conveted_LCMV_2/Time Delayed LCMV Beamformer/lcmv weigth calculator simplified/qrlinsolve/QR Factorization /Kp') - opens and selects block Kp\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'Fixed_point_conveted_LCMV_2/Time Delayed LCMV Beamformer/lcmv weigth calculator simplified/qrlinsolve'\r\n * '<S1>'   : 'Fixed_point_conveted_LCMV_2/Time Delayed LCMV Beamformer/lcmv weigth calculator simplified/qrlinsolve/QR Factorization '\r\n */\r\n#endif                                 /* RTW_HEADER_QR0_h_ */\r\n"},{"name":"QR0_private.h","type":"header","group":"model","path":"E:\\Projects\\Matlab\\Beamformer\\LCMV_Simulink\\QR0_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * QR0_private.h\r\n *\r\n * Code generation for model \"QR0\".\r\n *\r\n * Model version              : 1.312\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Tue Nov 21 14:00:25 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ASIC/FPGA->ASIC/FPGA\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (Custom Processor->MATLAB Host Computer)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_QR0_private_h_\r\n#define RTW_HEADER_QR0_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"multiword_types.h\"\r\n#include \"QR0_types.h\"\r\n#include \"QR0.h\"\r\n#include \"rtw_continuous.h\"\r\n#include \"rtw_solver.h\"\r\n\r\nextern real_T rt_hypotd(real_T u0, real_T u1);\r\nextern int32_T div_nde_s32_floor(int32_T numerator, int32_T denominator);\r\n\r\n#endif                                 /* RTW_HEADER_QR0_private_h_ */\r\n"},{"name":"QR0_types.h","type":"header","group":"model","path":"E:\\Projects\\Matlab\\Beamformer\\LCMV_Simulink\\QR0_grt_rtw","tag":"","groupDisplay":"Model files","code":"/*\r\n * QR0_types.h\r\n *\r\n * Code generation for model \"QR0\".\r\n *\r\n * Model version              : 1.312\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Tue Nov 21 14:00:25 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ASIC/FPGA->ASIC/FPGA\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (Custom Processor->MATLAB Host Computer)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_QR0_types_h_\r\n#define RTW_HEADER_QR0_types_h_\r\n#include \"rtwtypes.h\"\r\n#ifndef struct_tag_QIW5nCqoSKy8dzNm4TOLJ\r\n#define struct_tag_QIW5nCqoSKy8dzNm4TOLJ\r\n\r\nstruct tag_QIW5nCqoSKy8dzNm4TOLJ\r\n{\r\n  int32_T isInitialized;\r\n};\r\n\r\n#endif                                 /* struct_tag_QIW5nCqoSKy8dzNm4TOLJ */\r\n\r\n#ifndef typedef_dsp_simulink_QRFactorization__T\r\n#define typedef_dsp_simulink_QRFactorization__T\r\n\r\ntypedef struct tag_QIW5nCqoSKy8dzNm4TOLJ dsp_simulink_QRFactorization__T;\r\n\r\n#endif                             /* typedef_dsp_simulink_QRFactorization__T */\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_QR0_T RT_MODEL_QR0_T;\r\n\r\n#endif                                 /* RTW_HEADER_QR0_types_h_ */\r\n"},{"name":"multiword_types.h","type":"header","group":"utility","path":"E:\\Projects\\Matlab\\Beamformer\\LCMV_Simulink\\QR0_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * multiword_types.h\r\n *\r\n * Code generation for model \"QR0\".\r\n *\r\n * Model version              : 1.312\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Tue Nov 21 14:00:25 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ASIC/FPGA->ASIC/FPGA\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (Custom Processor->MATLAB Host Computer)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef MULTIWORD_TYPES_H\r\n#define MULTIWORD_TYPES_H\r\n#include \"rtwtypes.h\"\r\n\r\n/*\r\n * MultiWord supporting definitions\r\n */\r\ntypedef long long longlong_T;\r\n\r\n/*\r\n * MultiWord types\r\n */\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} int128m_T;\r\n\r\ntypedef struct {\r\n  int128m_T re;\r\n  int128m_T im;\r\n} cint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[2];\r\n} uint128m_T;\r\n\r\ntypedef struct {\r\n  uint128m_T re;\r\n  uint128m_T im;\r\n} cuint128m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} int192m_T;\r\n\r\ntypedef struct {\r\n  int192m_T re;\r\n  int192m_T im;\r\n} cint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[3];\r\n} uint192m_T;\r\n\r\ntypedef struct {\r\n  uint192m_T re;\r\n  uint192m_T im;\r\n} cuint192m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} int256m_T;\r\n\r\ntypedef struct {\r\n  int256m_T re;\r\n  int256m_T im;\r\n} cint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[4];\r\n} uint256m_T;\r\n\r\ntypedef struct {\r\n  uint256m_T re;\r\n  uint256m_T im;\r\n} cuint256m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} int320m_T;\r\n\r\ntypedef struct {\r\n  int320m_T re;\r\n  int320m_T im;\r\n} cint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[5];\r\n} uint320m_T;\r\n\r\ntypedef struct {\r\n  uint320m_T re;\r\n  uint320m_T im;\r\n} cuint320m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} int384m_T;\r\n\r\ntypedef struct {\r\n  int384m_T re;\r\n  int384m_T im;\r\n} cint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[6];\r\n} uint384m_T;\r\n\r\ntypedef struct {\r\n  uint384m_T re;\r\n  uint384m_T im;\r\n} cuint384m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} int448m_T;\r\n\r\ntypedef struct {\r\n  int448m_T re;\r\n  int448m_T im;\r\n} cint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[7];\r\n} uint448m_T;\r\n\r\ntypedef struct {\r\n  uint448m_T re;\r\n  uint448m_T im;\r\n} cuint448m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} int512m_T;\r\n\r\ntypedef struct {\r\n  int512m_T re;\r\n  int512m_T im;\r\n} cint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[8];\r\n} uint512m_T;\r\n\r\ntypedef struct {\r\n  uint512m_T re;\r\n  uint512m_T im;\r\n} cuint512m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} int576m_T;\r\n\r\ntypedef struct {\r\n  int576m_T re;\r\n  int576m_T im;\r\n} cint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[9];\r\n} uint576m_T;\r\n\r\ntypedef struct {\r\n  uint576m_T re;\r\n  uint576m_T im;\r\n} cuint576m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} int640m_T;\r\n\r\ntypedef struct {\r\n  int640m_T re;\r\n  int640m_T im;\r\n} cint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[10];\r\n} uint640m_T;\r\n\r\ntypedef struct {\r\n  uint640m_T re;\r\n  uint640m_T im;\r\n} cuint640m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} int704m_T;\r\n\r\ntypedef struct {\r\n  int704m_T re;\r\n  int704m_T im;\r\n} cint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[11];\r\n} uint704m_T;\r\n\r\ntypedef struct {\r\n  uint704m_T re;\r\n  uint704m_T im;\r\n} cuint704m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} int768m_T;\r\n\r\ntypedef struct {\r\n  int768m_T re;\r\n  int768m_T im;\r\n} cint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[12];\r\n} uint768m_T;\r\n\r\ntypedef struct {\r\n  uint768m_T re;\r\n  uint768m_T im;\r\n} cuint768m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} int832m_T;\r\n\r\ntypedef struct {\r\n  int832m_T re;\r\n  int832m_T im;\r\n} cint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[13];\r\n} uint832m_T;\r\n\r\ntypedef struct {\r\n  uint832m_T re;\r\n  uint832m_T im;\r\n} cuint832m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} int896m_T;\r\n\r\ntypedef struct {\r\n  int896m_T re;\r\n  int896m_T im;\r\n} cint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[14];\r\n} uint896m_T;\r\n\r\ntypedef struct {\r\n  uint896m_T re;\r\n  uint896m_T im;\r\n} cuint896m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} int960m_T;\r\n\r\ntypedef struct {\r\n  int960m_T re;\r\n  int960m_T im;\r\n} cint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[15];\r\n} uint960m_T;\r\n\r\ntypedef struct {\r\n  uint960m_T re;\r\n  uint960m_T im;\r\n} cuint960m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} int1024m_T;\r\n\r\ntypedef struct {\r\n  int1024m_T re;\r\n  int1024m_T im;\r\n} cint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[16];\r\n} uint1024m_T;\r\n\r\ntypedef struct {\r\n  uint1024m_T re;\r\n  uint1024m_T im;\r\n} cuint1024m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} int1088m_T;\r\n\r\ntypedef struct {\r\n  int1088m_T re;\r\n  int1088m_T im;\r\n} cint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[17];\r\n} uint1088m_T;\r\n\r\ntypedef struct {\r\n  uint1088m_T re;\r\n  uint1088m_T im;\r\n} cuint1088m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} int1152m_T;\r\n\r\ntypedef struct {\r\n  int1152m_T re;\r\n  int1152m_T im;\r\n} cint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[18];\r\n} uint1152m_T;\r\n\r\ntypedef struct {\r\n  uint1152m_T re;\r\n  uint1152m_T im;\r\n} cuint1152m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} int1216m_T;\r\n\r\ntypedef struct {\r\n  int1216m_T re;\r\n  int1216m_T im;\r\n} cint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[19];\r\n} uint1216m_T;\r\n\r\ntypedef struct {\r\n  uint1216m_T re;\r\n  uint1216m_T im;\r\n} cuint1216m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} int1280m_T;\r\n\r\ntypedef struct {\r\n  int1280m_T re;\r\n  int1280m_T im;\r\n} cint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[20];\r\n} uint1280m_T;\r\n\r\ntypedef struct {\r\n  uint1280m_T re;\r\n  uint1280m_T im;\r\n} cuint1280m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} int1344m_T;\r\n\r\ntypedef struct {\r\n  int1344m_T re;\r\n  int1344m_T im;\r\n} cint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[21];\r\n} uint1344m_T;\r\n\r\ntypedef struct {\r\n  uint1344m_T re;\r\n  uint1344m_T im;\r\n} cuint1344m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} int1408m_T;\r\n\r\ntypedef struct {\r\n  int1408m_T re;\r\n  int1408m_T im;\r\n} cint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[22];\r\n} uint1408m_T;\r\n\r\ntypedef struct {\r\n  uint1408m_T re;\r\n  uint1408m_T im;\r\n} cuint1408m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} int1472m_T;\r\n\r\ntypedef struct {\r\n  int1472m_T re;\r\n  int1472m_T im;\r\n} cint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[23];\r\n} uint1472m_T;\r\n\r\ntypedef struct {\r\n  uint1472m_T re;\r\n  uint1472m_T im;\r\n} cuint1472m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} int1536m_T;\r\n\r\ntypedef struct {\r\n  int1536m_T re;\r\n  int1536m_T im;\r\n} cint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[24];\r\n} uint1536m_T;\r\n\r\ntypedef struct {\r\n  uint1536m_T re;\r\n  uint1536m_T im;\r\n} cuint1536m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} int1600m_T;\r\n\r\ntypedef struct {\r\n  int1600m_T re;\r\n  int1600m_T im;\r\n} cint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[25];\r\n} uint1600m_T;\r\n\r\ntypedef struct {\r\n  uint1600m_T re;\r\n  uint1600m_T im;\r\n} cuint1600m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} int1664m_T;\r\n\r\ntypedef struct {\r\n  int1664m_T re;\r\n  int1664m_T im;\r\n} cint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[26];\r\n} uint1664m_T;\r\n\r\ntypedef struct {\r\n  uint1664m_T re;\r\n  uint1664m_T im;\r\n} cuint1664m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} int1728m_T;\r\n\r\ntypedef struct {\r\n  int1728m_T re;\r\n  int1728m_T im;\r\n} cint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[27];\r\n} uint1728m_T;\r\n\r\ntypedef struct {\r\n  uint1728m_T re;\r\n  uint1728m_T im;\r\n} cuint1728m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} int1792m_T;\r\n\r\ntypedef struct {\r\n  int1792m_T re;\r\n  int1792m_T im;\r\n} cint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[28];\r\n} uint1792m_T;\r\n\r\ntypedef struct {\r\n  uint1792m_T re;\r\n  uint1792m_T im;\r\n} cuint1792m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} int1856m_T;\r\n\r\ntypedef struct {\r\n  int1856m_T re;\r\n  int1856m_T im;\r\n} cint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[29];\r\n} uint1856m_T;\r\n\r\ntypedef struct {\r\n  uint1856m_T re;\r\n  uint1856m_T im;\r\n} cuint1856m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} int1920m_T;\r\n\r\ntypedef struct {\r\n  int1920m_T re;\r\n  int1920m_T im;\r\n} cint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[30];\r\n} uint1920m_T;\r\n\r\ntypedef struct {\r\n  uint1920m_T re;\r\n  uint1920m_T im;\r\n} cuint1920m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} int1984m_T;\r\n\r\ntypedef struct {\r\n  int1984m_T re;\r\n  int1984m_T im;\r\n} cint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[31];\r\n} uint1984m_T;\r\n\r\ntypedef struct {\r\n  uint1984m_T re;\r\n  uint1984m_T im;\r\n} cuint1984m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} int2048m_T;\r\n\r\ntypedef struct {\r\n  int2048m_T re;\r\n  int2048m_T im;\r\n} cint2048m_T;\r\n\r\ntypedef struct {\r\n  uint64_T chunks[32];\r\n} uint2048m_T;\r\n\r\ntypedef struct {\r\n  uint2048m_T re;\r\n  uint2048m_T im;\r\n} cuint2048m_T;\r\n\r\n#endif                                 /* MULTIWORD_TYPES_H */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"E:\\Projects\\Matlab\\Beamformer\\LCMV_Simulink\\QR0_grt_rtw","tag":"","groupDisplay":"Utility files","code":"/*\r\n * rtwtypes.h\r\n *\r\n * Code generation for model \"QR0\".\r\n *\r\n * Model version              : 1.312\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Tue Nov 21 14:00:25 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ASIC/FPGA->ASIC/FPGA\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (Custom Processor->MATLAB Host Computer)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n#include \"tmwtypes.h\"\r\n#ifndef POINTER_T\r\n#define POINTER_T\r\n\r\ntypedef void * pointer_T;\r\n\r\n#endif\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n#ifndef INT64_T\r\n#define INT64_T\r\n\r\ntypedef long long int64_T;\r\n\r\n#define MAX_int64_T                    ((int64_T)(9223372036854775807LL))\r\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807LL-1LL))\r\n#endif\r\n\r\n#ifndef UINT64_T\r\n#define UINT64_T\r\n\r\ntypedef unsigned long long uint64_T;\r\n\r\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFULL))\r\n#endif\r\n\r\n/*===========================================================================*\r\n * Additional complex number type definitions                                           *\r\n *===========================================================================*/\r\n#ifndef CINT64_T\r\n#define CINT64_T\r\n\r\ntypedef struct {\r\n  int64_T re;\r\n  int64_T im;\r\n} cint64_T;\r\n\r\n#endif\r\n\r\n#ifndef CUINT64_T\r\n#define CUINT64_T\r\n\r\ntypedef struct {\r\n  uint64_T re;\r\n  uint64_T im;\r\n} cuint64_T;\r\n\r\n#endif\r\n#endif                                 /* RTWTYPES_H */\r\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"E:\\Projects\\Matlab\\Beamformer\\LCMV_Simulink\\QR0_grt_rtw","tag":"","groupDisplay":"Interface files","code":"/*\r\n *  rtmodel.h:\r\n *\r\n * Code generation for model \"QR0\".\r\n *\r\n * Model version              : 1.312\r\n * Simulink Coder version : 23.2 (R2023b) 01-Aug-2023\r\n * C source code generated on : Tue Nov 21 14:00:25 2023\r\n *\r\n * Target selection: grt.tlc\r\n * Note: GRT includes extra infrastructure and instrumentation for prototyping\r\n * Embedded hardware selection: ASIC/FPGA->ASIC/FPGA\r\n * Emulation hardware selection:\r\n *    Differs from embedded hardware (Custom Processor->MATLAB Host Computer)\r\n * Code generation objective: Execution efficiency\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtmodel_h_\r\n#define RTW_HEADER_rtmodel_h_\r\n#include \"QR0.h\"\r\n#define GRTINTERFACE                   0\r\n\r\n/* Macros generated for backwards compatibility  */\r\n#ifndef rtmGetStopRequested\r\n#define rtmGetStopRequested(rtm)       ((void*) 0)\r\n#endif\r\n#endif                                 /* RTW_HEADER_rtmodel_h_ */\r\n"}],"coverage":[{"id":"SimulinkCoverage","name":"Simulink Coverage","files":[]},{"id":"Bullseye","name":"Bullseye Coverage","files":[]},{"id":"LDRA","name":"LDRA Testbed","files":[]}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true}};